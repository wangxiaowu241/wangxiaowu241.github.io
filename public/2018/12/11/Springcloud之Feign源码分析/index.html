<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="title: Springcloud之Feign源码分析date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: Springcloudtags: [java]description: 上一篇简单介绍了springcloud声明式服务调用Feign的使用，接下来分析下Feign的源码，具体实现及为什么如此实现。 启动时Feign的处理">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2018/12/11/Springcloud%E4%B9%8BFeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title: Springcloud之Feign源码分析date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: Springcloudtags: [java]description: 上一篇简单介绍了springcloud声明式服务调用Feign的使用，接下来分析下Feign的源码，具体实现及为什么如此实现。 启动时Feign的处理">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-12-11T08:32:13.943Z">
<meta property="article:modified_time" content="2021-05-23T05:49:06.980Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Springcloud之Feign源码分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/12/11/Springcloud%E4%B9%8BFeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2018-12-11T08:32:13.943Z" itemprop="datePublished">2018-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Springcloud之Feign源码分析<br>date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改<br>categories: Springcloud<br>tags: [java]<br>description: 上一篇简单介绍了springcloud声明式服务调用Feign的使用，接下来分析下Feign的源码，具体实现及为什么如此实现。</p>
<h2 id="启动时Feign的处理"><a href="#启动时Feign的处理" class="headerlink" title="启动时Feign的处理"></a>启动时Feign的处理</h2><p>启动类上使用了@EnableFeignClients注解，我们来看下这个注解在哪里使用了，使用idea只要在EnableFeignClients类上按住command同时点击类名就可以查看到这个类在哪里使用了，发现除了启动类，只在FeignClientsRegistrar类中引用了EnableFeignClients。</p>
<p>debug可以发现，当应用启动时会首先调用FeignClientsRegistrar的registerBeanDefinitions()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册默认配置信息</span></span><br><span class="line">   registerDefaultConfiguration(metadata, registry);</span><br><span class="line">    <span class="comment">//注册每个声明为Feign Client的类</span></span><br><span class="line">   registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要看下registerFeignClients()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取扫描classpath下component组件的扫描器</span></span><br><span class="line">   ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">   scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">   Set&lt;String&gt; basePackages;</span><br><span class="line">	<span class="comment">//获取启动类上配置的@EnableFeignClients注解的属性</span></span><br><span class="line">   Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">   AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">         FeignClient.class);</span><br><span class="line">    <span class="comment">//从刚才获取的@EnableFeignClients注解的属性中获取clients属性配置的值</span></span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">         : (Class&lt;?&gt;[]) attrs.get(<span class="string">&quot;clients&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//如果clients没配置</span></span><br><span class="line">       <span class="comment">//扫描器增加要扫描的过滤器(扫描被@FeignClient注解修饰的类)</span></span><br><span class="line">      scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">       <span class="comment">//获取配置的扫描包的路径，如果没配置，默认为启动类的包路径</span></span><br><span class="line">      basePackages = getBasePackages(metadata);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">          <span class="comment">//如果启动类配置了clients属性的值，将配置的client所在的包名加到扫描器扫描的包中</span></span><br><span class="line">         basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">         clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">      &#125;</span><br><span class="line">      AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">            String cleaned = metadata.getClassName().replaceAll(<span class="string">&quot;\\$&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      scanner.addIncludeFilter(</span><br><span class="line">            <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历包名，扫描@FeignClient注解修饰的类（怎么扫描到？前面加了扫描@FeignClient注解的IncludeFilter)</span></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">            .findCandidateComponents(basePackage);</span><br><span class="line">       <span class="comment">//遍历扫描出来的@FeignClient注解修饰的类</span></span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">         <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">             <span class="comment">//校验@FeignClient注解修饰的类是否是interface</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">             <span class="comment">//断言，@FeignClient注解修饰的类必须是interface</span></span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                  <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">//先获取@FeignClient注解的属性值</span></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                  .getAnnotationAttributes(</span><br><span class="line">                        FeignClient.class.getCanonicalName());</span><br><span class="line">			<span class="comment">//获得@FeignClient配置的client 的名称(name或value或serviceId)</span></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            <span class="comment">//注册feign client的配置信息</span></span><br><span class="line">             registerClientConfiguration(registry, name,</span><br><span class="line">                  attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">			<span class="comment">//注册feign client</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将feign client交由spring管理，声明为spring的bean</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="params"><span class="function">      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">   String className = annotationMetadata.getClassName();</span><br><span class="line">    <span class="comment">//创建FeignClientFactoryBean，包含将feign client的注解属性信息存入FeignClientFactoryBean中</span></span><br><span class="line">   BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">    <span class="comment">//校验feign client的配置，配置的fallback及fallbackFatory必须是实现类</span></span><br><span class="line">   validate(attributes);</span><br><span class="line">    <span class="comment">//将@FeignClient注解配置的属性放入FeignClientFactoryBean的BeanDefinitionBuilder中</span></span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;url&quot;</span>, getUrl(attributes));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;path&quot;</span>, getPath(attributes));</span><br><span class="line">   String name = getName(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;type&quot;</span>, className);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;decode404&quot;</span>, attributes.get(<span class="string">&quot;decode404&quot;</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;fallback&quot;</span>, attributes.get(<span class="string">&quot;fallback&quot;</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;fallbackFactory&quot;</span>, attributes.get(<span class="string">&quot;fallbackFactory&quot;</span>));</span><br><span class="line">   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">   String alias = name + <span class="string">&quot;FeignClient&quot;</span>;</span><br><span class="line">   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> primary = (Boolean)attributes.get(<span class="string">&quot;primary&quot;</span>); <span class="comment">// has a default, won&#x27;t be null</span></span><br><span class="line"></span><br><span class="line">   beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">   String qualifier = getQualifier(attributes);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">      alias = qualifier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">         <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">    <span class="comment">//注册bean到spring容器中</span></span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在spring容器启动时会调用FeignClientFactoryBean的getObject()方法（只有在其他bean注入feign client时才会调用），看下FeignClientFactoryBean的getObject()方法做了哪些处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//直接调用了getTarget()方法</span></span><br><span class="line">   <span class="keyword">return</span> getTarget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the target type of the Feign client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Feign&#125; client created with the specified data and the context information</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个FeignContext在FeignAutoConfiguration配置中已经声明了，所以可以直接用applicationContext获取bean</span></span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">    <span class="comment">//配置feign 的decoder、encoder、retryer、contract、RequestInterceptor等</span></span><br><span class="line">    <span class="comment">//这些有默认配置，在FeignAutoConfiguration及FeignClientsConfiguration中有默认配置</span></span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      <span class="comment">//如果@FeignClient注解上指定了url，其实除非本地调试，一般不建议指定URL</span></span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">         url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//处理URL，没配置URL时，这里的URL形式为http://name+/path</span></span><br><span class="line">      url += cleanPath();</span><br><span class="line">       <span class="comment">//使用负载均衡处理feign 请求</span></span><br><span class="line">      <span class="keyword">return</span> (T) loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//配置了FeignClient的具体URL</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not load balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter.class);</span><br><span class="line">   <span class="keyword">return</span> (T) targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>decoder：将http请求的response转换成对象</li>
<li>encoder：将http请求的对象转换成http request body</li>
<li>contract：校验Feign Client上的注解及value值是否合法</li>
<li>retryer：定义http请求如果失败了是否应该重试以及重试间隔、方式等等</li>
<li>RequestInterceptor：feign发起请求前的拦截器，可以全局定义basic auth、发起请求前自动添加header等等</li>
</ul>
<p>从@FeignClient注解上是否指定URL，feign的处理分成了两部分，如果未指定URL，则使用负载均衡去发送请求，指定URL，只会向指定的URL发送请求。</p>
<p>一般是不指定URL的，接下来先看下，不指定具体URL时，feign的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">loadBalance</span><span class="params">(Feign.Builder builder, FeignContext context,</span></span></span><br><span class="line"><span class="params"><span class="function">      HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认client为LoadBalancerFeignClient，为啥？参见DefaultFeignLoadBalancedConfiguration</span></span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.client(client);</span><br><span class="line">       <span class="comment">//这个Targeter默认为DefaultTargeter，参见FeignAutoConfiguration</span></span><br><span class="line">      Targeter targeter = get(context, Targeter.class);</span><br><span class="line">      <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         <span class="string">&quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Targeter默认为DefaultTargeter，client为LoadBalancerFeignClient。再看下DefaultTargeter.target()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="params"><span class="function">               Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Feign.target()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReflectiveFeign.newInstance()方法。这里为什么是ReflectiveFeign？参考Feign.build()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个apply方法就是ReflectiveFeign中的apply方法，返回了每个方法的调用包装类SynchronousMethodHandler</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line"><span class="comment">//这个target.type()返回的就是声明@FeignClient注解所在的class</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;</span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回了ReflectiveFeign.FeignInvocationHandler对象，这个对象的invoke方法其实就是调用了SynchronousMethodHandler.invoke方法</span></span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取类上的方法的元数据，如返回值类型，参数类型，注解数据等等</span></span><br><span class="line">  List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">  Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">  <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">    BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">    <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md, queryMapEncoder);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//这个factory是SynchronousMethodHandler.Factory，create方法返回了一个SynchronousMethodHandler对象</span></span><br><span class="line">    result.put(md.configKey(),</span><br><span class="line">               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单总结下启动时Feign所做的处理：</p>
<ul>
<li>获取@EnableFeignClients注解配置的扫描包路径，如果没配置，默认为启动类的包路径。</li>
<li>获得扫描包路径下@FeignClient修饰的类</li>
<li>校验@FeignClient修饰的类，包括类必须是interface，以及@FeignClient的fallback及fallbackFactory配置的必须是接口的实现类等</li>
<li>将@FeignClient修饰的类交由spring管理，声明为bean，其他bean注入FeignClient时注入的其实是当前FeignClient的代理类，这个代理类包装在Targeter内部，Targeter被注入到引用的bean中。</li>
</ul>
<p>这样做的好处是：在程序中使用Feign Client时就可以像其他spring 管理的bean一样直接注入即可。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CartFeignClient cartFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/toCart/&#123;productId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">addCart</span><span class="params">(<span class="meta">@PathVariable(&quot;productId&quot;)</span> Long productId)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    cartFeignClient.addCart(productId);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(productId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用Feign-Client时的feign的处理"><a href="#调用Feign-Client时的feign的处理" class="headerlink" title="调用Feign Client时的feign的处理"></a>调用Feign Client时的feign的处理</h2><p>刚分析了应用启动及bean注入FeignClient时feign的处理，知道注入的其实是Targeter类，Targetr类包装了FeignCLient的proxy，proxy内部绑定了methodHandler为SynchronousMethodHandler。接下来仔细分析下整个实际调用过程的处理。</p>
<p>前面提到feign实际处理方法调用的methodHandler是SynchronousMethodHandler。</p>
<p>实际上，首先调用的是ReflectiveFeign的静态内部类FeignInvocationHandler，这个类实现了JDK的InvocationHandler接口，在调用代理类的方法时会被调用FeignInvocationHandler的invoke方法。</p>
<p>FeignInvocationHandler的invoke方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object</span><br><span class="line">          otherHandler =</span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//除了equals、hashCode、toString方法外，其他方法都走dispatch.get(method).invoke(args)方法。</span></span><br><span class="line">  <span class="comment">//点击这个方法的实现类，就可以追到  SynchronousMethodHandler的invoke方法了。</span></span><br><span class="line">  <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到除了equals、hashCode、toString方法外，其他方法都走dispatch.get(method).invoke(args)方法。<br>点击这个方法的实现类，就可以追到  SynchronousMethodHandler的invoke方法了。所以这里其实只是简单起到转发的作用。</p>
<p>SynchronousMethodHandler的invoke方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">//根据调用参数创建一个RequestTemplate，用来具体处理http调用请求</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  <span class="comment">//克隆出一个一模一样的Retryer，用来处理调用失败后的重试</span></span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//发送http request以及处理response等  </span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      <span class="comment">//处理重试次数、重试间隔等等  </span></span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来看下如何创建的RequestTemplate。</p>
<p>ReflectiveFeign的内部静态类BuildTemplateByResolvingArgs的create方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestTemplate <span class="title">create</span><span class="params">(Object[] argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取methodMetada的template，这个RequestTemplate是可变的，跟随每次调用参数而变。</span></span><br><span class="line">  RequestTemplate mutable = <span class="keyword">new</span> RequestTemplate(metadata.template());</span><br><span class="line">  <span class="keyword">if</span> (metadata.urlIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//处理@PathVariable在URL上插入的参数  </span></span><br><span class="line">    <span class="keyword">int</span> urlIndex = metadata.urlIndex();</span><br><span class="line">    checkArgument(argv[urlIndex] != <span class="keyword">null</span>, <span class="string">&quot;URI parameter %s was null&quot;</span>, urlIndex);</span><br><span class="line">    mutable.insert(<span class="number">0</span>, String.valueOf(argv[urlIndex]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理调用方法的param参数，追加到URL ？后面的参数</span></span><br><span class="line">  Map&lt;String, Object&gt; varBuilder = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Integer, Collection&lt;String&gt;&gt; entry : metadata.indexToName().entrySet()) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = entry.getKey();</span><br><span class="line">    Object value = argv[entry.getKey()];</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123; <span class="comment">// Null values are skipped.</span></span><br><span class="line">      <span class="keyword">if</span> (indexToExpander.containsKey(i)) &#123;</span><br><span class="line">        value = expandElements(indexToExpander.get(i), value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String name : entry.getValue()) &#123;</span><br><span class="line">        varBuilder.put(name, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理query参数以及body内容	</span></span><br><span class="line">  RequestTemplate template = resolve(argv, mutable, varBuilder);</span><br><span class="line">  <span class="keyword">if</span> (metadata.queryMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// add query map parameters after initial resolve so that they take</span></span><br><span class="line">    <span class="comment">// precedence over any predefined values</span></span><br><span class="line">    <span class="comment">//当  RequestTemplate处理完参数后，再处理@QueryMap注入的参数，以便优先于任意值。</span></span><br><span class="line">    Object value = argv[metadata.queryMapIndex()];</span><br><span class="line">    Map&lt;String, Object&gt; queryMap = toQueryMap(value);</span><br><span class="line">    template = addQueryMapQueryParameters(queryMap, template);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metadata.headerMapIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//处理RequestTemplate的header内容  </span></span><br><span class="line">    template = addHeaderMapHeaders((Map&lt;String, Object&gt;) argv[metadata.headerMapIndex()], template);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，第一步是根据调用时的参数等构造了RequestTemplate的param、body、header等内容。</p>
<p>再看executeAndDecode方法。</p>
<p>SynchronousMethodHandler的executeAndDecode方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">//构造Request，将RequestTemplate中的参数等放入Request中</span></span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//这个client默认实现是Client接口中的Defalut，实现是通过HttpURLConnection发送请求</span></span><br><span class="line">    <span class="comment">//另一种是LoadBalancerFeignClient，默认也是Client接口中的Defalut，可以通过配置指定为Apache的HTTPClient，也可以指定为OKhttp来发送请求，在每个具体实现中来通过ribbon实现负载均衡，负载到集群中不同的机器，这里不再发散  </span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> shouldClose = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//处理response的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (Response.class == metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Ensure the response body is disconnected</span></span><br><span class="line">      <span class="keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      <span class="keyword">return</span> response.toBuilder().body(bodyData).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据状态码处理下response</span></span><br><span class="line">    <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">void</span>.class == metadata.returnType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object result = decode(response);</span><br><span class="line">        shouldClose = closeAfterDecode;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span>.class != metadata.returnType()) &#123;</span><br><span class="line">      Object result = decode(response);</span><br><span class="line">      shouldClose = closeAfterDecode;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<ul>
<li>代理类先调用到FeignInvocationHandler的invoke方法，而这个invoke方法相当于直接调用了SynchronousMethodHandler的invoke方法。</li>
<li>SynchronousMethodHandler的invoke方法主要是构造了RequestTemplate以及出现异常重试的Retryer，最后根据构造的RequestTemplate发起了http请求以及decode。</li>
<li>构造RequestTemplate时，根据传入的参数动态构建URL中的参数（@PathVarible）以及URL ？追加的参数，还有body等等，最后再处理@QueryMap注入的参数，以保证优先级最高。</li>
<li>发起http请求时，没有负载均衡时，默认是通过JDK的HttpURLConnection发送请求，另一种就是LoadBalancerFeignClient各种实现类，如Apache的HTTPClient，以及OKhttp等，这些实现也是通过ribbon动态指定服务器IP地址，以达到负载均衡的作用。</li>
<li>最后将response处理成需要的返回值类型，以及根据状态码进行decode。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/11/Springcloud%E4%B9%8BFeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckp0rgif70000es85hr6hfm25" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/23/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/23/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/12/11/Springcloud%E4%B9%8BFeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>